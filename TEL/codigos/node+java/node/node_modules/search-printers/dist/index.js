'use strict';

var net = require('net');
var os = require('os');

function tryConnect({ host, port, timeout, buffer }) {
    return new Promise(resolve => {
        let serviceSocket = net.connect({
            host: host,
            port: port,
            timeout: timeout
        }, function () {
            serviceSocket.write(buffer);
        });
        let timeoutId;
        let name = "";
        serviceSocket.on("data", data => {
            name = name + data.toString("utf8");
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                serviceSocket.destroy();
                resolve({
                    host: host,
                    port: port,
                    name: name.replace(/\0/g, "")
                });
            }, timeout);
        });
        serviceSocket.on("timeout", () => {
            serviceSocket.destroy();
            resolve();
        });
        serviceSocket.on("error", () => {
            serviceSocket.destroy();
            resolve();
        });
    });
}

function getValidInterfaces() {
    const interfaces = os.networkInterfaces();
    let validInterfaces = [];
    Object.values(interfaces).forEach(inf => {
        validInterfaces = validInterfaces.concat(inf.filter(i => !i.internal && i.family === "IPv4"));
    });
    return validInterfaces;
}
function getBroadcastAddress(interfaceInfo) {
    let address = interfaceInfo.address.split(".");
    let netmask = interfaceInfo.netmask.split(".");
    return address.map((e, i) => (~netmask[i] & 0xff) | e);
}
function getBaseAddress(interfaceInfo) {
    let address = interfaceInfo.address.split(".");
    let netmask = interfaceInfo.netmask.split(".");
    return address.map((e, i) => netmask[i] & e);
}
function getNetworkAddress(interfaceInfo) {
    return {
        base: getBaseAddress(interfaceInfo),
        broadcast: getBroadcastAddress(interfaceInfo)
    };
}

const GET_PRINTER_NAME = Buffer.from([
    0x1b,
    0x3d,
    0x01,
    0x1d,
    0x49,
    0x45,
    0x1d,
    0x49,
    0x43,
    0x1d,
    0x49,
    0x42
]);
async function getPrinters(options) {
    const { timeout, port, buffer } = Object.assign({
        timeout: 3000,
        port: 9100,
        buffer: GET_PRINTER_NAME
    }, options);
    const ifaces = getValidInterfaces();
    const promises = [];
    ifaces.map(getNetworkAddress).forEach(({ base, broadcast }) => {
        let isValid = base.every((mask) => mask >= 0 && mask <= 255);
        isValid =
            isValid && broadcast.every((mask) => mask >= 0 && mask <= 255);
        if (!isValid)
            return;
        const startIP = (base[0] << 24) | (base[1] << 16) | (base[2] << 8) | base[3];
        const endIP = (broadcast[0] << 24) |
            (broadcast[1] << 16) |
            (broadcast[2] << 8) |
            broadcast[3];
        for (let i = startIP + 1; i < endIP; i++) {
            const ipParts = [
                ((i & 0xff000000) >> 24) & 0xff,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff
            ];
            promises.push(tryConnect({
                host: ipParts.join("."),
                port: port,
                timeout: timeout,
                buffer: buffer
            }));
        }
    });
    const devices = await Promise.all(promises);
    return devices.filter(Boolean);
}

module.exports = getPrinters;
